---
description: 'Git のチーム開発フローにおけるコミット粒度・コミットメッセージ・履歴品質のルールとベストプラクティス'
applyTo: '**/*'
---

# 目的とスコープ
このドキュメントは、チーム開発における **コミット粒度**、**コミットメッセージ**、**履歴品質**（レビュー容易性・安全なロールバック・原因特定のしやすさ）を高めるためのルールとベストプラクティスを定義します

# コミット粒度（コア原則）
- 無関係な変更は別コミットに分割する
  - **理由**: レビューが速くなり、部分 revert や原因特定（`git bisect`）が容易になる
- 1 コミットは「1 つの論理的変更」にする（1 文で説明できる単位）
- 可能な範囲で、各コミットは単体でビルド・テスト可能な状態に寄せる
  - **理由**: 中間コミットが壊れていると、調査・revert・cherry-pick のコストが増える
- 1 コミットはビルド・テスト可能な範囲で最小のサイズにする
  - **理由**: 手戻りの際の負担が少なくなるため
- ステージングで意図した差分だけを含める（`git add -p` を活用する）
- 「機械的変更（整形・リネーム・移動）」と「意味のある変更（ロジック・仕様）」を同じコミットに混ぜない
- リファクタと挙動変更は原則分ける（ただし挙動変更を安全にするために必要な最小限のリファクタは例外）
- ロジック変更と「フォーマットのみ」の変更を同一コミットに混ぜない
- 依存関係更新と機能開発を同一コミットに束ねない（機能の前提なら例外として、その理由を本文に書く）
- main に入る履歴に「WIP」「とりあえず」「あとで直す」コミットを残さない
- リモートにブランチが存在せず、force pushしないですむ場合、 `fixup!` / `squash!` を使い、マージ前に `--autosquash` で履歴を整形する

# いつ分割するか（判断基準）
- 変更理由が異なる場合は分割する（例: バグ修正とリファクタ、依存更新と機能追加）
- レビュアーが変わりそうなら分割する（例: UI と DB、フロントとバック）
- ロールバックのリスクが異なるなら分割する（例: 安全な整理と挙動変更）
- 差分を上から読んだときに、頭のコンテキストを頻繁に切り替える必要があるなら分割する
- ファイル数が多くても「本質的な挙動変更」が少数ファイルなら、機械的変更は別コミットに分ける
- import文の修正などエラーが発生しない場合は「リネーム/移動のみ」コミットには内容編集を入れない（diff が追いにくくなるため）

# コミットメッセージ（メッセージ規約）
- リポジトリに既存のコミットメッセージ規約がある場合は、それに従う
- 件名（1 行目）は短く具体的に書く
- 重要な変更・リスクのある変更は本文で「何を」「なぜ」を補足する
- 必要に応じて Issue/Ticket 番号を付ける
- “update”“fix”“misc” など、対象が分からない曖昧な件名は避ける
- コミットメッセージは英語ラベルと日本語の体言止めで書く
- ラベルとスコープを使用する 例: `ラベル（スコープ）: 日本語で短く具体的で体言止めの件名`

## 使用可能なコミットメッセージラベル（例）と使い分け

- `feat`: ユーザー価値のある機能追加（新 API、画面の新機能、仕様追加）
- `fix`: バグ修正（不具合・例外・回帰の修正）
- `refactor`: 挙動を変えない内部改善（構造整理、責務分離、読みやすさ向上）
- `perf`: パフォーマンス改善（計測や根拠があるのが望ましい）
- `test`: テスト追加・修正（仕様確認、回帰テスト、テスト基盤）
- `docs`: ドキュメントのみの変更（README、設計メモ、コメント整備）
- `style`: 見た目の整形のみ（フォーマッタ適用、空白、セミコロン、lint の自動修正など）
- `dev`: 開発体験向上（devcontainer、エディタ設定、開発用スクリプト）
- `revert`: 以前のコミットを取り消す（`git revert` が作る形式に合わせる）
- `chore`: ビルド/運用/周辺作業/その他上記に当てはまらない変更（依存更新、CI 設定、生成物更新、ツール設定、雑務）

### ラベルの使用タイミング例
- フォーマットだけ直した → `style`
- リファクタして読みやすくした（挙動は不変）→ `refactor`
- ヌル入力で落ちるのを防いだ → `fix`
- 新しい検索条件を追加した → `feat`
- 依存を上げただけ → `chore`
- devcontainer を整備した → `dev`

## スコープの内容
- 作業内容のうち、下記のカテゴリのうち最も関連性が深いものを採用する
  - ドメイン名
  - レイヤー名
  - ツール名

## ラベル、スコープ付きメッセージ例
- `feat(api): タスク検索にフィルタを追加`
- `fix(ui): モーダルの二重送信を防止`
- `refactor(db): クエリ組み立てを抽出`
- `style(ruff): Ruff フォーマッタ適用（挙動変更なし）`
- `chore(ruff): Ruff の依存関係を更新`
- `dev: ローカル開発用スクリプトを追加`

# 履歴品質
- 「準備 → 変更 → テスト」の流れが読みやすいコミット列を目指す
- 純粋なリファクタは先のコミットに置き、挙動変更コミットの差分を小さく見せる
- 最終履歴は「論理的変更 1 つを 1 回の revert で戻せる」ことを意識する
- 作業中は小さく刻み、最終的に読みやすい履歴に整える

# コミット分割・整形のコマンド例（代表パターン）
## 変更を小分けにステージしてコミットする（基本）
```bash
git add -p
git commit -m "refactor: バリデーション処理を抽出"

git add -p
git commit -m "fix: null 入力で落ちないように修正"
```

## ステージから外す（ステージの調整）
```bash
git restore --staged path/to/file
# 旧コマンド（同等の用途）
git reset path/to/file
```

## 直前のコミットに差分を追加・修正する（履歴を書き換える）
```bash
git add -p
git commit --amend
```

## 混ぜた 1 コミットを「分割」して作り直す（ローカルで履歴を書き換える）
```bash
git reset --mixed HEAD~1

git add -p
git commit -m "refactor: ..."

git add -p
git commit -m "fix: ..."
```

## 複数コミットを並べ替え・結合・分割する（インタラクティブ rebase）
```bash
git rebase -i HEAD~5
```
- `pick`: そのまま
- `reword`: メッセージだけ修正
- `edit`: そのコミットで止めて分割/修正
- `squash` / `fixup`: 前のコミットにまとめる

## fixup/squash を使って最後に整形する（push前のみ）
```bash
git commit --fixup <commit-sha>
git rebase -i --autosquash <base-branch>
```

## 一時退避しつつ部分的に作業を進める（混線防止）
```bash
git stash -p
git stash pop
```

# 禁止事項
- 巨大な「全部入りコミット」を作成しない
- 理由なく「リポジトリ全体にフォーマッタ適用」を混ぜない（実施するなら専用コミットにする）
- コミットを綺麗に見せる目的だけで、意味のある変更（命名・設計・挙動）を勝手に混ぜない
- リモートにカレントブランチが存在する場合にforce pushが必要になる履歴修正は行わない
  - `git ls-remote --heads origin "$(git branch --show-current)"`で確認
- コミット前に `git branch --show-current` で現在のブランチ名を取得し、下記ブランチであれば処理を停止しユーザーに「現在のブランチでのコミットは禁止されています」と伝える
  - main
  - master
  - staging
